#pragma once
// ReSharper disable CppUnusedIncludeDirective

// ------ commonly used stuff from the standard library ------
#include <vector>
#include <deque>
#include <array>
#include <string>
#include <string_view>
#include <exception>
#include <stdexcept>
#include <unordered_map>
#include <unordered_set>
#include <map>
#include <functional>
#include <memory>
#include <iostream>
#include <ostream>
#include <fstream>
#include <queue>
#include <algorithm>
#include <variant>
#include <iomanip>
#include <optional>
#include <typeinfo>
#include <atomic>
#include <mutex>
#include <condition_variable>
#include <cstdlib>
#include <typeindex>
#include <type_traits>
#include <utility>
#include <cstdint>
#include <chrono>
#include <filesystem>

#include <cstdio>
#include <cassert>

// ----------------------- externals -----------------------
#define FMT_HEADER_ONLY
#include <fmt/format.h>
#include <fmt/ostream.h>
#include <fmt/chrono.h>
#include <stb_image.h>

#include <assimp/Importer.hpp>  // C++ importer interface
#include <assimp/scene.h>       // Output data structure
#include <assimp/postprocess.h> // Post processing flags
#include <assimp/anim.h>

#include <cpplinq.hpp>

#include <nlohmann/json.hpp>

// GLM: 
#if defined(USE_VULKAN_CONTEXT)
// DEFINES:
#define VK_ENABLE_BETA_EXTENSIONS
#define GLFW_INCLUDE_VULKAN
#define VK_USE_PLATFORM_WIN32_KHR

// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default. 
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition. [1]
#define GLM_FORCE_DEPTH_ZERO_TO_ONE
#endif
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>
#include <glm/gtc/quaternion.hpp>
#include <glm/ext/quaternion_float.hpp>
#include <glm/ext/quaternion_common.hpp>
#include <glm/ext/quaternion_geometric.hpp>
#include <glm/ext/quaternion_trigonometric.hpp>
#include <glm/ext/quaternion_exponential.hpp>
#include <glm/ext/quaternion_relational.hpp>
#include <glm/ext/quaternion_transform.hpp>
#include <glm/mat4x4.hpp>
#define GLM_ENABLE_EXPERIMENTAL
#include <glm/gtx/transform2.hpp>
#include <glm/gtx/hash.hpp>

// -------------------- windows include ---------------------
#ifdef _WIN32
// Include that after the assimp includes due to some conflict
// with the global scope operator :: in material.inl
#define NOMINMAX
#include <windows.h>
#endif

#include <ak/ak.hpp>

// -------------------- CG-Base includes --------------------
#include "cgb_exceptions.hpp"
#include "string_utils.hpp"
#include "log.hpp"
#include "essential_utils.hpp"
#include "various_utils.hpp"
#include "context_state.hpp"
#include "device_queue_selection_strategy.hpp"

#include "cursor.hpp"

#if defined(USE_OPENGL_CONTEXT)
#include <glad/glad.h>
#include "buffer_member_format_opengl.hpp"
#include "image_opengl.hpp"
#include "image_view_opengl.hpp"
#elif defined(USE_VULKAN_CONTEXT)
#include <vulkan/vulkan.hpp>
static_assert( VK_HEADER_VERSION >= 131 , "VK_HEADER_VERSION must be greater than or equal 131 (SDK 1.1.131.1 or newer)." );

#endif


#if defined(USE_OPENGL_CONTEXT)
#include "context_generic_glfw_types.hpp"
#include "window_base.hpp"
#include "context_generic_glfw.hpp"
#include "sampler_opengl.hpp"
#include "image_sampler_opengl.hpp"
#include "command_buffer_opengl.hpp"
#include "semaphore_opengl.hpp"
#include "fence_opengl.hpp"
#include "buffer_opengl.hpp"
#include "renderpass_opengl.hpp"
#include "framebuffer_opengl.hpp"
#include "window_opengl.hpp"
#include "shader_opengl.hpp"
#include "binding_data_opengl.hpp"
#include "graphics_pipeline_config.hpp"
#include "pipeline_opengl.hpp"
#include "bindings_opengl.hpp"

#include "context_opengl.hpp"
#include "context.hpp"
#elif defined(USE_VULKAN_CONTEXT)
#include "context_generic_glfw_types.hpp"
#include "window_base.hpp"

#include "window.hpp"
#include "context_generic_glfw.hpp"

#include "vulkan_helper_functions.hpp"


#include "vk_convenience_functions.hpp"

#include "context_vulkan.hpp"
#include "context.hpp"


// [1] Vulkan Tutorial, Rendering and presentation, https://vulkan-tutorial.com/Drawing_a_triangle/Drawing/Rendering_and_presentation
// [2] Vulkan Tutorial, Vertex buffer creation, https://vulkan-tutorial.com/Vertex_buffers/Vertex_buffer_creation
// [3] Vulkan Tutorial, Images, https://vulkan-tutorial.com/Texture_mapping/Images
// [4] Vulkan Tutorial, Image view and sampler, https://vulkan-tutorial.com/Texture_mapping/Image_view_and_sampler
#endif



#include "math_utils.hpp"
#include "key_code.hpp"
#include "key_state.hpp"
#include "timer_interface.hpp"
#include "timer_frame_type.hpp"
#include "fixed_update_timer.hpp"
#include "varying_update_timer.hpp"

#include "input_buffer.hpp"
#include "composition_interface.hpp"

namespace cgb
{
#pragma region global data representing the currently active composition
	/**	@brief Get the current timer, which represents the current game-/render-time
	 *	\remark This is just a shortcut to @ref composition_interface::current()->time();
	 */
	inline timer_interface& time()
	{
		return composition_interface::current()->time();
	}

	/** @brief Get the current frame's input data
	 *	\remark This is just a shortcut to @ref composition_interface::current()->input();
	 */
	inline input_buffer& input()
	{
		return composition_interface::current()->input();
	}

	/** @brief Get access to the currently active objects
	 *	\remark This is just a shortcut to @ref *composition_interface::current();
	 */
	inline composition_interface& current_composition()
	{
		return *composition_interface::current();
	}
#pragma endregion 
}

#include "cg_element.hpp"
#include "sequential_executor.hpp"
#include "composition.hpp"
#include "setup.hpp"

#include "transform.hpp"
#include "material_config.hpp"
#include "material_gpu_data.hpp"
#include "material.hpp"
#include "lightsource.hpp"
#include "lightsource_gpu_data.hpp"
#include "camera.hpp"
#include "model.hpp"
#include "quake_camera.hpp"
#include "orca_scene.hpp"

#include "material_image_helpers.hpp"

#include "imgui_manager.hpp"

// ReSharper restore CppUnusedIncludeDirective



	// f32
	template <>	inline vk::Format format_for<glm::vec<4, glm::f32, glm::defaultp>>()	{ return vk::Format::eR32G32B32A32Sfloat; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::f32, glm::defaultp>>()	{ return vk::Format::eR32G32B32Sfloat(); }
	template <>	inline vk::Format format_for<glm::vec<2, glm::f32, glm::defaultp>>()	{ return vk::Format::eR32G32Sfloat(); }
	template <>	inline vk::Format format_for<glm::vec<1, glm::f32, glm::defaultp>>()	{ return vk::Format::eR32Sfloat(); }
	template <>	inline vk::Format format_for<float>()									{ return vk::Format::eR32Sfloat(); }
	// f64
	template <>	inline vk::Format format_for<glm::vec<4, glm::f64, glm::defaultp>>()	{ return vk::Format::eR64G64B64A64Sfloat; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::f64, glm::defaultp>>()	{ return vk::Format::eR64G64B64Sfloat; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::f64, glm::defaultp>>()	{ return vk::Format::eR64G64Sfloat; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::f64, glm::defaultp>>()	{ return vk::Format::eR64Sfloat; }
	template <>	inline vk::Format format_for<double>()									{ return vk::Format::eR64Sfloat; }
	// i8
	template <>	inline vk::Format format_for<glm::vec<4, glm::i8, glm::defaultp>>()		{ return vk::Format::eR8G8B8A8Sint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::i8, glm::defaultp>>()		{ return vk::Format::eR8G8B8Sint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::i8, glm::defaultp>>()		{ return vk::Format::eR8G8Sint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::i8, glm::defaultp>>()		{ return vk::Format::eR8Sint; }
	template <>	inline vk::Format format_for<int8_t>()									{ return vk::Format::eR8Sint; }
	// i16
	template <>	inline vk::Format format_for<glm::vec<4, glm::i16, glm::defaultp>>()	{ return vk::Format::eR16G16B16A16Sint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::i16, glm::defaultp>>()	{ return vk::Format::eR16G16B16Sint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::i16, glm::defaultp>>()	{ return vk::Format::eR16G16Sint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::i16, glm::defaultp>>()	{ return vk::Format::eR16Sint; }
	template <>	inline vk::Format format_for<int16_t>()									{ return vk::Format::eR16Sint; }
	// i32
	template <>	inline vk::Format format_for<glm::vec<4, glm::i32, glm::defaultp>>()	{ return vk::Format::eR32G32B32A32Sint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::i32, glm::defaultp>>()	{ return vk::Format::eR32G32B32Sint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::i32, glm::defaultp>>()	{ return vk::Format::eR32G32Sint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::i32, glm::defaultp>>()	{ return vk::Format::eR32Sint; }
	template <>	inline vk::Format format_for<int32_t>()									{ return vk::Format::eR32Sint; }
	// i64
	template <>	inline vk::Format format_for<glm::vec<4, glm::i64, glm::defaultp>>()	{ return vk::Format::eR64G64B64A64Sint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::i64, glm::defaultp>>()	{ return vk::Format::eR64G64B64Sint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::i64, glm::defaultp>>()	{ return vk::Format::eR64G64Sint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::i64, glm::defaultp>>()	{ return vk::Format::eR64Sint; }
	template <>	inline vk::Format format_for<int64_t>()									{ return vk::Format::eR64Sint; }
	// u8
	template <> inline vk::Format format_for<glm::vec<4, glm::u8, glm::defaultp>>()		{ return vk::Format::eR8G8B8A8Uint; }
	template <> inline vk::Format format_for<glm::vec<3, glm::u8, glm::defaultp>>()		{ return vk::Format::eR8G8B8Uint; }
	template <> inline vk::Format format_for<glm::vec<2, glm::u8, glm::defaultp>>()		{ return vk::Format::eR8G8Uint; }
	template <> inline vk::Format format_for<glm::vec<1, glm::u8, glm::defaultp>>()		{ return vk::Format::eR8Uint; }
	template <> inline vk::Format format_for<uint8_t>()									{ return vk::Format::eR8Uint; }
	// u16
	template <>	inline vk::Format format_for<glm::vec<4, glm::u16, glm::defaultp>>()	{ return vk::Format::eR16G16B16A16Uint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::u16, glm::defaultp>>()	{ return vk::Format::eR16G16B16Uint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::u16, glm::defaultp>>()	{ return vk::Format::eR16G16Uint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::u16, glm::defaultp>>()	{ return vk::Format::eR16Uint; }
	template <>	inline vk::Format format_for<uint16_t>()								{ return vk::Format::eR16Uint; }
	// u32
	template <>	inline vk::Format format_for<glm::vec<4, glm::u32, glm::defaultp>>()	{ return vk::Format::eR32G32B32A32Uint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::u32, glm::defaultp>>()	{ return vk::Format::eR32G32B32Uint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::u32, glm::defaultp>>()	{ return vk::Format::eR32G32Uint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::u32, glm::defaultp>>()	{ return vk::Format::eR32Uint; }
	template <>	inline vk::Format format_for<uint32_t>()								{ return vk::Format::eR32Uint; }
	// u64
	template <>	inline vk::Format format_for<glm::vec<4, glm::u64, glm::defaultp>>()	{ return vk::Format::eR64G64B64A64Uint; }
	template <>	inline vk::Format format_for<glm::vec<3, glm::u64, glm::defaultp>>()	{ return vk::Format::eR64G64B64Uint; }
	template <>	inline vk::Format format_for<glm::vec<2, glm::u64, glm::defaultp>>()	{ return vk::Format::eR64G64Uint; }
	template <>	inline vk::Format format_for<glm::vec<1, glm::u64, glm::defaultp>>()	{ return vk::Format::eR64Uint; }
	template <>	inline vk::Format format_for<uint64_t>()								{ return vk::Format::eR64Uint; }